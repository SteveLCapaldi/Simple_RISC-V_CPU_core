`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 2024/05/07 19:54:24
// Design Name: 
// Module Name: rom1
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////


module rom1 #(  
    parameter DWIDTH = 32,  
    parameter AWIDTH = 32,  
    parameter DEPTH  = 32  
)(  
    input rst,  
    input [AWIDTH - 1 : 0] PC,  
    input en_fetch,  
    output reg [DWIDTH - 1 : 0] instruction
    //output reg en_in  
);  
    reg [DWIDTH - 1 : 0] mem[0 : DEPTH - 1];  
  
    initial begin  
        // 初始化ROM内容（仅示例）  
       /* mem[0] = 32'h0000_0000; //inst=0 
        mem[1] = 32'h0000_0037; // LUI,将r0作为基址寄存器，且基址为0
        mem[2] = 32'h0000_2083;//LW,求得内存地址0，将该位置上的值导入r1(r1=1)
        mem[3] = 32'h0000_A103;//LW,求得内存地址1，将该位置上的值导入r2(r2=2)
        mem[4] = 32'h0001_2183;//LW,求得内存地址2，将该位置上的值导入r3(r3=3)
        mem[5] = 32'h0012_1163;//BNE,偏移量为2；
        mem[6] = 32'h0010_8093;//ADDI,r1再加上1（r1=2)
        mem[7] = 32'h0010_8113;//ADDI,r1再加上1给r2(r2=3) 
        mem[8] = 32'h0020_D083;//ADD,r1加上r2，再给r1(r1=5)     
        // ... 其他地址的初始化  */
        mem[0] = 32'h0000_0000; //inst=0
        mem[1] = 32'b00000000000000000000000000110111;//  LUI 0
        mem[2] = 32'b00000000000100000010000010000011;//LW将1load进寄存器地址1 000000000001  00000 010 00001 0000011
        mem[3] = 32'b00000000001000000010000100000011;//LW将2load斤寄存器地址2 000000000010  00000 010 00010 0000011
        mem[4] = 32'b0000000_00001_00001_010_00011_0100011;//SW将寄存器1的值存入寄存器1的地址+2的ram 0000000 00001 00001 010 00011 0100011
       // mem[4] = 32'b00000000000100001000000010010011;//addi 寄存器1的值和立即数1相加并存在寄存器1 32'b000000000001 00001 000 00001 0010011
        //mem[5] = 32'b00000000001000001000000110110011 ;//ADD，寄存器1加寄存器2存在寄存器3 32'b0000000 00010 00001 000 00011 0110011 
       // mem[6] = 32'b01000000000100011000001000110011 ;//SUB寄存器3减寄存器1，存在寄存器4 32'b 0100000 00011 00001 000 00100 0110011 
        //mem[7] = 32'b0_0_000000_00011_00100_000_0010_0_1100011;//BEQ，寄存器3和寄存器4比较offset是2
        //mem[7] = 32'b0_0_000000_00011_00100_001_0001_0_1100011;//BNE，寄存器3和寄存器4比较offset是2
        //mem[7] = 32'b000000000010_00001_000_01001_1100111;//JALR 寄存器1的值加上PC作为新PC，将PC+1存入寄存器9
       // mem[7] = 32'b0_0000000010_0_00000000_01001_1101111;//JAL PC+immm(2)，pc+1存入寄存器9
        //mem[7]= 32'b0000000_00001_00010_001_01001_0110011;//SLL，寄存器2左移寄存器1的2位，存在寄存器9
        //mem[7] = 32'b0000000_00010_00001_001_01010_0010011;//SLLI,寄存器1左移2位，存在寄存器10
        
       // mem[8] = 32'b0000000_00011_00001_010_00101_0110011;// SLT，寄存器1和寄存器3比较，寄存器5置一
       // mem[9] = 32'b0000000_00001_00011_010_00110_0110011;// SLT，寄存器3和寄存器1比较，寄存器6置0
        //mem[10] = 32'b000000000111_00001_111_00111_0010011;//ANDI 寄存器1和立即数7与，存在寄存器7
        //mem[11] = 32'b000000011000_00001_100_01000_0010011;//XORI 寄存器1和立即数24异或，存在寄存器8
        //mem[12] = 32'b000000000010_00001_000_01001_1100111;//JALR 寄存器1的值加上PC作为新PC，将PC+1存入寄存器9
    end  

    always @(*) begin  
        if (rst == 1) begin  
            // 复位时，输出无效指令和valid为0  
            instruction = 0;  
        end else if (en_fetch) begin  
            // 如果ready为高 
            instruction = mem[PC];

        end else begin  
            // 如果ready为低，不读取新指令
            // 这里不需要做任何事情，因为instruction和valid在rst或ready为真的条件下已经被设置了  
        end  
    end  
  
endmodule